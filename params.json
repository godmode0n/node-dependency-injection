{"name":"Node-dependency-injection","tagline":"Dependency injection with configuration and autowire for node js and browser.","body":"# Dependency injection\r\n\r\nDependency injection with configuration and autowire for node js and browser (for example in combination with [simq](https://npmjs.org/package/simq)).\r\n\r\nImagine, that you have got some classes which are used very often. You have got two options: add instance of these classes\r\nto window object or to any other object, or create new instance every time when you want to use them.\r\n\r\nThe problem is that first solution add some \"mess\" to the window object and the other one is even more problematic. What\r\nif you will want to change for example constructor of this class (it's arguments) or call some methods right after class\r\nis instanced? Than you will have to change these setups at every place.\r\n\r\nBut with this package, you can configure your classes at one place and then let's just \"ask\" for them. (not service locator).\r\n\r\nThis package is inspired by dependency injection in [Nette framework](http://doc.nette.org/en/dependency-injection).\r\n\r\n## Installation\r\n\r\n```\r\n$ npm install dependency-injection\r\n```\r\n\r\n## Configuration\r\n\r\nPlease first read full documentation of [easy-configuration](https://github.com/sakren/node-easy-configuration). It will\r\nreally help you.\r\n\r\n\r\n```\r\n{\r\n\t\"services\": {\r\n\t\t\"application\": {\r\n    \t\t\"service\": \"path/to/my/application/module\",\r\n    \t\t\"arguments\": [\"./www\", \"someOtherVariable\"],\r\n    \t\t\"setup\": {\r\n    \t\t\t\"setApplicationName\": [\"nameOfApplication\"],\r\n    \t\t\t\"setSomethingOther\": [\"someUselessVariable\", \"andAnotherOne\"]\r\n    \t\t}\r\n    \t}\r\n\t}\r\n}\r\n```\r\n\r\nThere we set some application service with some arguments which will be given to constructor and some setup. Every time\r\nyou will need this service, it will have got these arguments and all setup function will be called.\r\n\r\nSection service is path for module require (common js).\r\n\r\nDI automatically look into values from setup in your module (service). If it is function, then it will be called, otherwise\r\nargument will be passed into this object property.\r\n\r\n## Usage\r\n\r\n```\r\nvar DIConfigurator = require('dependency-injection/DIConfigurator');\r\nvar configurator = new DIConfigurator('./path/to/your/configuration/file.json');\r\n\r\nvar di = configurator.create();\r\n```\r\n\r\n**Relative paths to config files are supported only on node (not in browser)!!!**\r\n\r\nThis will create new instance of DI class which holding all your services.\r\n\r\nYou have to also set the basePath property. DI will prepend this basePath to all services' paths from your configuration.\r\nSo it should be path to root directory of your application.\r\n\r\nIn example below, you can see how to get your services.\r\n\r\n```\r\ndi.get('application');\r\ndi.create('application');\r\ndi.getFactory('application');\r\n```\r\n\r\n## Base path to services\r\n\r\nDefault base path in node is directory of file from which you are initializing DI. You have to set this manually in browser.\r\n\r\n```\r\ndi.basePath = __dirname;\r\n```\r\n\r\n## Auto exposing into global\r\n\r\nDI can be automatically exposed into window object (when on browser) or into global object (in node). Default name for\r\nthis object is `di`.\r\n\r\n```\r\n{\r\n\t\"setup\": {\r\n\t\t\"expose\": true\r\n\t}\r\n}\r\n```\r\n\r\nCustom name:\r\n\r\n```\r\n{\r\n\t\"setup\": {\r\n\t\t\"expose\": \"secondDI\"\r\n\t}\r\n}\r\n```\r\n\r\n### get\r\n\r\nSome services may be \"singleton\" type (not really singleton but with one instance in whole application), which application\r\nservice is clearly is.\r\n\r\nThis method will create one instance of service and store it. Every other time, this instance will be returned.\r\n\r\n### getByPath\r\n\r\nSame as `get` method, but this accepts path to node module (like in your service configuration)\r\n\r\n### create\r\n\r\nMethod create will just create new instance of service and will not store it.\r\n\r\n### getFactory\r\n\r\ngetFactory is almost the same like create method, but will return anonymous function, so if you then want to use it,\r\nyou have to call it.\r\n\r\n```\r\nvar application = di.getFactory('application');\r\napplication = application();\t\t// just call it\r\n```\r\n\r\n## Not instantiate services\r\n\r\nWhen you want for example use jQuery as service, you will not want to automatically call something like `new jquery`.\r\nSo you can tell DI, that this service will not be instantiate.\r\n\r\n```\r\n{\r\n\t\"services\": {\r\n\t\t\"jquery\": {\r\n\t\t\t\"service\": \"jquery\"\r\n\t\t\t\"instantiate\": false\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n## Auto run services\r\n\r\nWhen you are using configuration with json files, you can set some services to be started automatically after calling\r\nthe `create` method.\r\n\r\n```\r\n{\r\n\t\"services\": {\r\n\t\t\"setup\": {\r\n\t\t\t\"service\": \"./path/to/setup\",\r\n\t\t\t\"run\": true\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n## Autowiring\r\n\r\nAccessing some DI object is not so pretty like we want, so there is some nice way how to avoid it. You can let DI to \"inject\"\r\nall your services to other. For example if your application service needs translator service, just let DI to give it to\r\napplication.\r\n\r\nAll you need to do is add parameter \"translator\" to constructor of your application service. This name must be same like\r\nname of service in your configuration. DI then automatically give it translator service.\r\n\r\nThe same thing is also for methods. You don't have to configure them, just set name of needed service in method's arguments\r\nand DI will give you these services.\r\n\r\nThis is quite similar to dependency injection in [angular](http://angularjs.org/).\r\n\r\nNow in most cases you just have to use `get` method just once for create instance of your base application service\r\nand other services will be automatically injected.\r\n\r\nPlease, try to avoid circular dependencies (service A depends on service B and service B depends on service A).\r\n\r\n## Examples\r\n\r\nIn your configuration, you can use three dots as replacement for services.\r\n\r\nServices:\r\n```\r\nvar serviceA = function(serviceB, serviceC) { ... };\r\nvar serviceB = function(serviceC, namespace, item) { ... };\r\nvar serviceC = function(namespace, item, serviceD) { ... };\r\nvar serviceD = function() { ... };\r\n```\r\n\r\nConfiguration:\r\n```\r\n{\r\n\t\"services\": {\r\n\t\t\"serviceA\": {\r\n\t\t\t\"service\": \"path/to/service/A\",\r\n\t\t\t\"instantiate\": false\r\n\t\t},\r\n\t\t\"serviceB\": {\r\n\t\t\t\"service\": \"path/to/service/B\",\r\n\t\t\t\"arguments\": [\"...\", \"some namespace\", \"some item\"],\r\n\t\t\t\"instantiate\": false\r\n\t\t},\r\n\t\t\"serviceC\": {\r\n\t\t\t\"service\": \"path/to/service/C\",\r\n\t\t\t\"arguments\": [\"some namespace\", \"some item\"],\r\n\t\t\t\"instantiate\": false\r\n\t\t},\r\n\t\t\"serviceD\": {\r\n\t\t\t\"service\": \"path/to/service/D\",\r\n\t\t\t\"instantiate\": false\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\nor more expanded:\r\n```\r\n{\r\n\t\"services\": {\r\n\t\t\"serviceA\": {\r\n\t\t\t\"service\": \"path/to/service/A\",\r\n\t\t\t\"arguments\": [\"...\"],\r\n\t\t\t\"instantiate\": false\r\n\t\t},\r\n\t\t\"serviceB\": {\r\n\t\t\t\"service\": \"path/to/service/B\",\r\n\t\t\t\"arguments\": [\"...\", \"some namespace\", \"some item\"],\r\n\t\t\t\"instantiate\": false\r\n\t\t},\r\n\t\t\"serviceC\": {\r\n\t\t\t\"service\": \"path/to/service/C\",\r\n\t\t\t\"arguments\": [\"some namespace\", \"some item\", \"...\"],\r\n\t\t\t\"instantiate\": false\r\n\t\t},\r\n\t\t\"serviceD\": {\r\n\t\t\t\"service\": \"path/to/service/D\",\r\n\t\t\t\"arguments\": [\"...\"],\r\n\t\t\t\"instantiate\": false\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\nOnly problem is with minified javascript files which changes variable names. Solution for this is write some kind of hint\r\nfor DI container.\r\n\r\n```\r\nvar someFunction = function(otherNameForApplicationService) {\r\n\t{'@di:inject': ['@application']};\t\t\t// services' names are prepended with '@'\r\n\r\n\totherNameForApplicationService.run();\t\t// this will call method run on service application\r\n};\r\n```\r\n\r\nor you can also include services by their full paths:\r\n```\r\nvar someFunction = function(otherNameForApplicationService) {\r\n\t{'@di:inject': ['$path/to/application/service']};\t\t// services' paths are prepended with '$'\r\n\r\n\totherNameForApplicationService.run();\r\n};\r\n```\r\n\r\nor if you need factory:\r\n```\r\nvar someFunction = function(otherNameForApplicationService) {\r\n\t{'@di:inject': ['factory:$path/to/application/service']};\t\t// can also be name of service: \"factory:@application\"\r\n\r\n\totherNameForApplicationService.run();\r\n};\r\n```\r\n\r\nThese hints has got the same syntax as arguments configuration.\r\n\r\n### Disable autowiring\r\n\r\nIf you want to disable autowiring for some service, you can set \"autowired\" option to false in your config (like instantiate).\r\n\r\nWhen you will try to autowire this service, DI will throw an error.\r\n\r\n```\r\n{\r\n\t\"services\": {\r\n\t\t\"setup\": {\r\n\t\t\t\"someName\": \"./path/to/this/service\",\r\n\t\t\t\"autowired\": false\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n## Autowire factories\r\n\r\nYou can also let DI to autowire factories. For example if you want to get factory for translator, you will add \"Factory\"\r\nto the end of translator.\r\n\r\n```\r\nMyClass.prototype.setTranslator = function(translatorFactory) {\r\n\tvar translator = translatorFactory();\t\t\t// now do something with translator\r\n};\r\n```\r\n\r\n## Links to other services\r\n\r\nWhen you have got for example foreign library registered as service in this DI and want to autowire some other service into\r\nit, you have to use their names of methods arguments.\r\n\r\nAnother possibility is to set these services in your config.\r\n\r\n```\r\n{\r\n\t\"services\": {\r\n\t\t\"foreignLibrary\": {\r\n\t\t\t\"service\": \"path/to/service\",\r\n\t\t\t\"arguments\": [\r\n\t\t\t\t\"@translator\"\r\n\t\t\t]\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\nor with full module path:\r\n```\r\n{\r\n\t\"services\": {\r\n\t\t\"foreignLibrary\": {\r\n\t\t\t\"service\": \"path/to/service\",\r\n\t\t\t\"arguments\": [\r\n\t\t\t\t\"$path/to/translator/module\"\r\n\t\t\t]\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\nNow this `foreignLibrary` will gets your `translator` service in constructor.\r\n\r\n## Default services\r\n\r\nThere are already prepared some services.\r\n\r\n* `di`: di container itself\r\n* `timer`: object with `setTimeout`, `setInterval`, `clearTimeout` and `clearInterval` methods\r\n* `window`: window object (browser only)\r\n* `document`: window.document object (browser only)\r\n* `global`: global object (node.js only)\r\n\r\n```\r\ndi.get('di');\r\n```\r\n\r\n## Parameters\r\n\r\nIn documentation of [easy-configuration](https://github.com/sakren/node-easy-configuration) you can see that you can use\r\nalso parameters. This is useful for example for setting your services.\r\n\r\n```\r\n{\r\n\t\"parameters\": {\r\n\t\t\"database\": {\r\n\t\t\t\"user\": \"root\",\r\n\t\t\t\"password\": \"toor\"\r\n\t\t}\r\n\t},\r\n\t\"services\": {\r\n\t\t\"database\": {\r\n\t\t\t\"service\": \"database/connection\",\r\n\t\t\t\"arguments\": [\r\n\t\t\t\t\"%database.user%\",\r\n\t\t\t\t\"%database.password%\"\r\n\t\t\t]\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\nCredentials for database connection will be root and toor.\r\n\r\nOr you can access these parameters from di object.\r\n\r\n```\r\nconsole.log(di.parameters);\t\t\t\t\t\t\t// whole object of expanded parameters\r\nconsole.log(di.getParameter('database.user');\t\t// root\r\n```\r\n\r\n`getParameter()` method is just shortcut to [getParameter](https://github.com/sakren/node-easy-configuration/blob/master/src/EasyConfiguration.coffee#L173)\r\nmethod in [easy-configuration](https://github.com/sakren/node-easy-configuration).\r\n\r\n## Advanced configuration\r\n\r\nIf you need more control over configuration, you can create instance of `easy-configuration` object on your own and pass\r\nit to DIConfigurator.\r\n\r\n```\r\nvar Config = require('easy-configuration');\r\nvar DIConfigurator = require('dependency-injection/DIConfigurator');\r\n\r\nvar config = new Config;\r\nconfig.addConfig('./path/to/config.json', 'development');\r\n\r\nvar configurator = new DIConfigurator(config);\r\nvar di = configurator.create();\r\n```\r\n\r\n## Without configuration\r\n\r\nMaybe it will be better for someone to use this DI without configuration, so here is example of application, translator\r\nand jquery definition.\r\n\r\n```\r\nvar DI = require('dependency-injection');\r\nvar di = new DI;\r\n\r\ndi.addService('application', require('./path/to/my/application/module'), ['./www', 'someOtherVariable'])\r\n\t.addSetup('setApplicationName', ['nameOfApplication'])\r\n\t.addSetup('setSomethingOther', ['someUselessVariable', 'andAnotherOne']);\r\n\r\ndi.addService('translator', require('./path/to/translator'))\r\n\t.addSetup('setLanguage', ['en']);\r\n\r\ndi.addService('jquery', 'jquery')\r\n\t.setInstantiate(false);\r\n\r\ndi.addService('private', 'my/private/service')\r\n\t.setAutowired(false);\r\n```\r\n\r\nInstead of path to service (second parameter in addService method) you can also use string with path, but this path will be\r\nthen relative to class of DI!\r\n\r\n## Create instance\r\n\r\nIf you have got some other object which you want to use with other services, but can not use configuration or DI for this,\r\nyou can use `createInstance` method and DI will create new instance of your object with dependencies defined in constructor.\r\n\r\n```\r\nvar SuperClass = require('./mySuperClass');\r\nvar super = di.createInstance(SuperClass, ['and some argument']);\r\n```\r\n\r\n## Inject method\r\n\r\nFor simple injecting services into your functions, you can use method `inject`.\r\n\r\n```\r\ndi.inject(function(application) {\r\n\tapplication.doSomeMagic();\r\n});\r\n```\r\n\r\nor with arguments\r\n\r\n```\r\ndi.inject(function(application, path) {\r\n\tapplication.setPath(path);\r\n}, ['...', '/path/to/some/folder']);\t\t// syntax is same like in configuration\r\n```\r\n\r\nyou can of course use also autowire hints.\r\n\r\n## Tests\r\n\r\n```\r\n$ npm test\r\n```\r\n\r\n## Changelog\r\n\r\n* 2.2.0\r\n\t+ Relative paths to config files\r\n\t+ Little updates in tests\r\n\t+ Added default services\r\n\t+ Better documentation\r\n\t+ Many improvements in configuration (see [easy-configuration](https://github.com/sakren/node-easy-configuration))\r\n\r\n* 2.1.1\r\n\t+ Hints has exactly the same syntax as arguments configuration\r\n\t+ Inject method's second argument is args, not scope (BC break!)\r\n\r\n* 2.1.0\r\n\t+ Added [config](https://github.com/sakren/node-easy-configuration) object do DIConfigurator\r\n\t+ Bug with exposing\r\n\t+ Accessing parameters from di instance\r\n\t+ Updated dependencies\r\n\r\n* 2.0.1\r\n\t+ Injecting by arguments and hints was not working\r\n\r\n* 2.0.0\r\n\t+ Removed autowiring into `inject` methods (BC break!)\r\n\t+ Added methods `getByPath` and `getFactoryByPath`\r\n\t+ Added basePath option\r\n\t+ Better docs\r\n\t+ Added hints for autowiring\r\n\r\n* 1.8.0\r\n\t+ Better tests (mocha does not need to be installed globally)\r\n\t+ Updated dependencies\r\n\t+ Added badges\r\n\t+ Added to travis\r\n\r\n* 1.7.3\r\n\t+ Bug with no-string arguments\r\n\r\n* 1.7.2\r\n\t+ Bug with functions as services\r\n\r\n* 1.7.1\r\n\t+ Potential bug in IE\r\n\r\n* 1.7.0\r\n\t+ Updated dependencies\r\n\t+ Added `injectMethods` to services\r\n\t+ Refactored autowiring\r\n\t+ Some optimizations\r\n\t+ `DI.autowireArguments` moved to `Helpers.autowireArguments`\r\n\t+ Throwing an error if circular reference is found\r\n\r\n* 1.6.6 - 1.6.7\r\n\t+ Bugs in Internet Explorer 8\r\n\r\n* 1.6.2 - 1.6.5\r\n\t+ Some optimizations\r\n\t+ Should assert module replaced with chai\r\n\t+ Better error messages\r\n\r\n* 1.6.1\r\n\t+ Bug with setting other arguments than strings\r\n\r\n* 1.6.0\r\n\t+ Added `get` method, `getByName` is now deprecated\r\n\t+ Added `inject` method\r\n\t+ Autowiring with @\r\n\r\n* 1.5.2\r\n\t+ Add setup into properties\r\n\r\n* 1.4.1\r\n\t+ Bug\r\n\r\n* 1.4.0\r\n\t+ Option for exposing di into\r\n\r\n* 1.3.2 - 1.3.3\r\n\t+ Bug with run option\r\n\r\n* 1.3.1\r\n\t+ Just some mistake in readme\r\n\r\n* 1.3.0\r\n\t+ Added auto run option into configuration\r\n\t+ Really huge mistake in readme\r\n\r\n* 1.2.3\r\n\t+ Autowiring parameters even if they are not in function definition\r\n\r\n* 1.2.2\r\n\t+ Added missing test\r\n\r\n* 1.2.1\r\n\t+ Added ability to inject DI container itself\r\n\r\n* 1.2.0\r\n\t+ Added DI.createInstance method\r\n\t+ DI.addService accepts also objects\r\n\t+ Typos in README\r\n\t+ Optimizations\r\n\t+ Added mocha tests\r\n\t+ Added setInstantiate method\r\n\t+ Added autowired option\r\n\r\n* 1.1.1\r\n\t+ inject methods are called before custom setup\r\n\r\n* 1.1.0\r\n\t+ Support for not-instantiate services\r\n\r\n* 1.0.1\r\n\t+ Added information about autowiring factories\r\n\r\n* 1.0.0\r\n\t+ Initial version","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}